<html>
<head>
  <title>A D3 map</title>
  <script type="text/javascript" src="./d3.js"></script>
  <script src="neighborhoods.js"></script>
  <script src="groupedBarChart.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <style>
    #neighborhoods path{
      fill: #ccc;
    }
.container {
  float: left;
}
  </style>
</head>

<div>
  <svg  id="switch_data"> </svg>
</div>
<div>
    <input type="text" id="long1" placeholder="Longitude &hellip;">
    <input type="text" id="lat1" placeholder="Latitude&hellip;">
    <input name="Plot"  type="submit" value="Plot" onclick= "return submit(1)">
    <input type="text" id="long2" placeholder="Longitude&hellip;">
    <input type="text" id="lat2" placeholder="Latitude&hellip;">
    <input name="Compare"  type="submit" value="Compare"onclick= "return submit(2)" >
    <input name="Clean"  type="submit" value="Clean"onclick= "return clear_pings()" >
</div>

<div class ="container"><svg id="map"> </svg></div>

<div class ="container">
  <svg id="my_dataviz2"></svg>
</div>
<div id="barchart">
  
</div>
<body>
  <script>


// https://stackoverflow.com/questions/45421774/how-to-draw-circles-with-radii-given-in-kilometers-accurately-on-world-map
var circumference = 6371000 * Math.PI * 2;
var angle = 1000 / circumference * 360;
var zoom_transform ={trans:null};
function clear_pings(){
  ping.selectAll("path").remove();
  d3.selectAll("#barchart svg").remove();
  return false
}


function submit(num_pings){
  var data = []
  lat = parseFloat(document.getElementById("lat1").value);
  long = parseFloat(document.getElementById("long1").value);
  datum = {"lat":lat,"long":long}
  data.push(datum)
  if(num_pings>1){
    lat = parseFloat(document.getElementById("lat2").value);
    long = parseFloat(document.getElementById("long2").value);
    datum = {"lat":lat,"long":long}
    data.push(datum)
  }
  _render_bar_chart(data)
  draw_pings(data)
  return false;
}

function _render_bar_chart(pings){
  var barchart_data = []
  pings.forEach(ping => {
    filtered_data=_filter_by_distance(ping);
    processed_data = _to_count_dict(filtered_data);
    barchart_data.push(processed_data);
  });
  draw_grouped_bar_chart(barchart_data)
  
}
function _to_count_dict(filtered_data){
  var counts = filtered_data.reduce((p, c) => {
  var name = c.type;
  if (!p.hasOwnProperty(name)) {
    p[name] = 0;
  }
  p[name]++;
  return p;
}, {});

console.log(counts);
return counts
}
function _filter_by_distance(ping){
  var filtered_data = raw_data.filter(function(d){
    return distance(d.latitude,d.longitude,ping.lat,ping.long,"K")<=1;
  })
  console.log(filtered_data)
  return filtered_data
}
function draw_pings(data){
  console.log(data)

  var color = ["red","blue"];
  var ping_circle =ping.selectAll( "path" )
  .data(data,function(d){return d.long+""+d.lat;})
  ping_circle.enter()
  .append("path")
  .attr("d", function(d){
    console.log(d)
    var circle = d3.geoCircle().center([d.long,d.lat ]).radius(angle);
    return geoPath(circle())
  })
  .style("fill",function(d,i){
    return color[i]
  })
  .attr("opacity","0.5");
  ping_circle.exit()
  .remove();
  ping.selectAll( "path" ).attr('transform',zoom_transform.trans);
}
var width = 350,
    height = 400;

var svg = d3.select( "#map" )
  .attr( "width", width )
  .attr( "height", height );

var neighborhoods = svg.append( "g" ).attr( "id", "neighborhoods" );
var ping = svg.append("g").attr("id","ping");
var svg = d3.select("#my_dataviz2").attr( "width", width ).attr( "height", height );
var legend = svg.append('g').attr("id","legend")



var albersProjection = d3.geoAlbers()
  .scale( 100000 )
  .rotate( [71.057,0] )
  .center( [0, 42.313] )
  .translate( [width/2,height/2] );

var geoPath = d3.geoPath()
    .projection( albersProjection );

neighborhoods.selectAll( "path" )
  .data( neighborhoods_json.features )
  .enter()
  .append( "path" )
  .attr( "d", geoPath )
  .style("stroke", "#fff")
  ;



  neighborhoods.selectAll( "text" )
  .data( neighborhoods_json.features )
  .enter()
  .append( "text" )
  .attr("x", function(d) {
                   return albersProjection( albersProjection.invert (geoPath.centroid(d))) [0];
           })
           .attr("y", function(d) {
                   return albersProjection( albersProjection.invert (geoPath.centroid(d))) [1];
           })
  .attr("fill", "black")
  .style("text-anchor", "middle")
  .style("font-size","10px")
  .text(function(d){ return d.properties.Name})
  .raise();

  


  function type(d) {
          d.latitude = +d.latitude;
          d.longitude = +d.longitude;
          return d;
      } 
var raw_data;
d3.csv("./clean.csv", type).then(function(d){
  raw_data = d;
  render(d)
})
_render_switch_data()
const remove = new Set()

function _render_switch_data(){

  var data = ["clean","quiet"]
  var width =100,height = 50;

  var svg = d3.select( "#switch_data" )
    .attr( "width", "100%" )
    .attr( "height", height );
    g = svg.append("g")
     
   
        // Add one dot in the legend for each name.
        g.selectAll("dots")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", function(d,i){ return 10+i*100})
        .attr("cy", 25 ) // 100 is where the first dot appears. 25 is the distance between dots
        .attr("r", 7)
        .attr("id",function(d,i){ return  !i ? "clean": "quiet"})
        .style("fill", function(d,i){ return  !i ? "red": "white"})
        .style("stroke", function(d,i){ return   "red"})
        .on('click',on_click_filter)

      // Add one dot in the legend for each name.
      g.selectAll("labels")
        .data(data)
        .enter()
        .append("text")
        .attr("x", function(d,i){ return 30+i*100})
        .attr("y", 25 )  // 100 is where the first dot appears. 25 is the distance between dots
          .style("fill", function(d){ return "black"})
          .text(function(d){ return d})
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle")


    function on_click_filter(event,d){
      var new_data;
        if (d3.select(this).style("fill") == "white"){
          d3.select(this).style("fill","red")
          .attr("stroke",function(d){ return "white"})
          var isclean = d3.select(this).attr('id') == "clean"
          if (isclean){
            d3.select("#quiet").style("fill","white")
            d3.csv("./clean.csv").then(function(d){
  raw_data = d;
  render(d)
})
          }
          else{
            d3.select("#clean").style("fill","white")
            d3.csv("./quiet.csv").then(function(d){
  raw_data = d;
  render(d)
})
          }
        }
    }

}


function _render_map(new_data,color,zoom_transform){
  raw_data = new_data
  console.log(zoom_transform)
var circles = neighborhoods.selectAll("circle").attr('transform',zoom_transform.trans).data(new_data,function(d) { return(d); });
circles.enter()
  .append( "circle" )
  .attr( "cx", function(d){
    return albersProjection( [d.longitude,d.latitude] )[0] ;
  })
  .attr( "cy", function(d){
    return albersProjection( [d.longitude,d.latitude] )[1] ;
  })
  .attr("r", 2)
  .attr("fill",d=>color(d.type)).style("opacity", 0.8)

  .on( "click", function(event,d){
    console.log([d.longitude,d.latitude]);
    d3.select(this)
      .attr("opacity",1)
      .transition()
      .duration( 1000 )
      .attr( "cx", width * Math.round( Math.random() ) )
      .attr( "cy", height * Math.round( Math.random() ) )
      
      .attr( "opacity", 0 )
      .on("end",function(){
        d3.select(this).remove();
      })
  });
  circles.exit().remove()
  neighborhoods.selectAll('text').raise();
  if(zoom_transform.trans){
  neighborhoods.selectAll("circle")
                  .attr('transform', zoom_transform.trans);
  neighborhoods.selectAll("circle")
                  .attr('r',2/zoom_transform.trans.k)
  }
}

function _render_label(data, keys,color,zoom_transform){

  function on_click_filter(event,d){
    var new_data;
      if (d3.select(this).style("fill") != "white"){
        d3.select(this).style("fill","white")
        .attr("stroke",function(d){ return color(d)})
        remove.add(d)
        new_data = data.filter(function(d){return !remove.has(d.type)})
        
      }
      else {
        d3.select(this).style("fill",function(d){ return color(d)}).attr("stroke","white")
        remove.delete(d)
        new_data = data.filter(function(d){return !remove.has(d.type)})
      }
      _render_map(new_data,color,zoom_transform)

}

  
 
    // Add one dot in the legend for each name.
    colors =legend.selectAll("circle")
      .data(keys,function(d){return d});
    colors.enter()
      .append("circle")
        .attr("cx", 100)
        .attr("cy", function(d,i){ return 100 + i*25}) // 100 is where the first dot appears. 25 is the distance between dots
        .attr("r", 7)
        .style("fill", function(d){ return color(d)})
        .on('click',on_click_filter);
    colors.exit().remove();

      // Add one dot in the legend for each name.
      labels = legend.selectAll("text")
        .data(keys,function(d){return d});
      labels.enter()
        .append("text")
          .attr("x", 120)
          .attr("y", function(d,i){ return 100 + i*25}) // 100 is where the first dot appears. 25 is the distance between dots
          .style("fill", function(d){ return color(d)})
          .text(function(d){ return d})
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle");

          labels.exit().remove();
            
}
     
function render(data) {
   
    var keys = new Set(data.map(x=>x.type))

    var color = d3.scaleOrdinal().domain(keys).range(d3.schemeSet1);

    _render_map(data,color,zoom_transform)
    _render_label(data,keys,color,zoom_transform)
    


        var zoom = d3.zoom()
              .scaleExtent([1, 10])
              .on('zoom', function(event,d) {
                zoom_transform.trans=event.transform
                ping.selectAll('path')
                  .attr('transform', event.transform);
                neighborhoods.selectAll('path')
                  .attr('transform', event.transform);
                  neighborhoods.selectAll("circle")
                  .attr('transform', event.transform);
                  neighborhoods.selectAll("circle")
                  .attr('r',2/event.transform.k)
                neighborhoods.selectAll('text')
                .attr('transform', event.transform).style("font-size",10/event.transform.k+"px").raise();
        });

        neighborhoods.call(zoom);
}


function distance(lat1, lon1, lat2, lon2, unit) {
	if ((lat1 == lat2) && (lon1 == lon2)) {
		return 0;
	}
	else {
		var radlat1 = Math.PI * lat1/180;
		var radlat2 = Math.PI * lat2/180;
		var theta = lon1-lon2;
		var radtheta = Math.PI * theta/180;
		var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
		if (dist > 1) {
			dist = 1;
		}
		dist = Math.acos(dist);
		dist = dist * 180/Math.PI;
		dist = dist * 60 * 1.1515;
		if (unit=="K") { dist = dist * 1.609344 }
		if (unit=="N") { dist = dist * 0.8684 }
		return dist;
	}
}
  </script>
</body>
</html>