<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>311 Calls</title>
		<script src="https://d3js.org/d3.v6.min.js"></script>
        <style>

            @font-face {
              font-family: Karrik;
              src: url(https://gitlab.com/phantomfoundry/karrik_fonts/-/raw/main/fonts/Web/WOFF/Karrik-Regular.woff?inline=false);
            }

            h1, h2, h3 {
              font-family: Karrik;
            }
                  
            circle {
              opacity: 0.5;
            }

            #container {
              min-width: 100vw;
              max-width: 800px;
              margin: auto;
              display: flex;   
              justify-content: center;
              flex-flow: column wrap;
            }

            #container > div {
              margin: auto;
              flex-direction: column;
            }

            .button_container > div {
              display: inline-block;
              display: -moz-inline-box;
              *display: inline; /* For IE7 */
              zoom: 1; /* Trigger hasLayout */
              width: 10%;
              text-align: center;
            }

            .button_container {
              display: inline-block;
              display: -moz-inline-box;
              *display: inline; /* For IE7 */
              width: 50%;
              min-width: 400px;
            }

            button {
              width: 80%;
            }
      
          </style>
	</head>
	<body>

    <div id="container"> 
      
      <div><h2>choose city council district</h2></div>
      <div class="button_container">
        
        <div><button onclick="switchDistrict(0)">1</button></div>
        <div><button onclick="switchDistrict(1)">2</button></div>
        <div><button onclick="switchDistrict(2)">3</button></div>
        <div><button onclick="switchDistrict(3)">4</button></div>
        <div><button onclick="switchDistrict(4)">5</button></div>
        <div><button onclick="switchDistrict(5)">6</button></div>
        <div><button onclick="switchDistrict(6)">7</button></div>
        <div><button onclick="switchDistrict(7)">8</button></div>
        <div><button onclick="switchDistrict(8)">9</button></div>
        
      </div>

    </div>
    
		<script type="text/javascript">

    // i use this later on
    const clamp = (num, min, max) => { return Math.min(Math.max(num, min), max) }

    var ccd_data_overdue = [];
    var ccd_data_total = [];
    allXScalesTotal = [];
    allXScalesOverdue = [];
    var subgroups = [];
    var groups = [];
    var onTimelabels = [];
    var xScaleOnTime;
    var yScalesOnTime = [];
    var onTimeData;
    var x, y, color, svg;

    var yAxis_ontime;
    var xAxis_top = [];
    var yAxis_top = [];

    
    color = d3.scaleOrdinal()
        .domain([0,1])
        .range(['#377eb8','#4daf4a'])


    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 100, left: 50},
        w = 600 - margin.left - margin.right,
        h = 600 - margin.top - margin.bottom;
    Promise.all([
      d3.csv("./csv/1.csv", type),
      d3.csv("./csv/2.csv", type),
      d3.csv("./csv/3.csv", type),
      d3.csv("./csv/4.csv", type),
      d3.csv("./csv/5.csv", type),
      d3.csv("./csv/6.csv", type),
      d3.csv("./csv/7.csv", type),
      d3.csv("./csv/8.csv", type),
      d3.csv("./csv/9.csv", type),
    ]).then(function(allData) {
      subgroups = allData[0].columns.slice(1).slice(1,3)

      // Add Y axis
      let y0 = d3.scaleLinear()
        .domain([0, 10000])
        .range([ h - margin.bottom, 0 ]);
      let y1 = d3.scaleLinear()
        .domain([0, 10000])
        .range([ h - margin.bottom, 0]);

      y = [y0, y1];




      for(var i=0; i < allData.length; i++) {
          
        // top 10 most commonly overdue types of cases
          sortedDataOverdue = allData[i].sort(function(x,y) {
            return d3.descending(x.overdue, y.overdue)
          })
          groupsOverdue = d3.map(sortedDataOverdue.slice(0,10), (d) => {return d.type});

        // creates stacked data for overdue
          var stackedDataOverdue = d3.stack()
            .keys(subgroups)
            (sortedDataOverdue)

          // top 10 most common types of cases
          sortedDataTotal = allData[i].sort(function(x,y) {
            return d3.descending(x.overdue + x.ontime, y.overdue + y.ontime)
          })
          groupsTotal = d3.map(sortedDataTotal.slice(0,10), (d) => {return d.type})

          // creates stacked data for most common
          var stackedDataTotal = d3.stack()
            .keys(subgroups)
            (sortedDataTotal);

          // create X axis scale for overdue
          xOverdue = d3.scaleBand()
              .domain(groupsOverdue)
              .range([0, w])
              .padding([0.5]);

          // create X axis scale for total
          xTotal = d3.scaleBand()
              .domain(groupsTotal)
              .range([0, w])
              .padding([0.5]);


          // store the scales
          allXScalesTotal.push(xTotal)
          allXScalesOverdue.push(xOverdue)

          // store the stacked data
          ccd_data_overdue.push(stackedDataOverdue.map((d) => d.slice(0, 10)))
          ccd_data_total.push(stackedDataTotal.map((d) => d.slice(0, 10)))
          
      }
      render(ccd_data_total, 0, allXScalesTotal, 0 )
      render(ccd_data_overdue, 0, allXScalesOverdue, 1)
    });
    
    Promise.all([
      d3.csv("./csv/ontime1.csv", typeOnTime),
      d3.csv("./csv/ontime2.csv", typeOnTime),
      d3.csv("./csv/ontime3.csv", typeOnTime),
      d3.csv("./csv/ontime4.csv", typeOnTime),
      d3.csv("./csv/ontime5.csv", typeOnTime),
      d3.csv("./csv/ontime6.csv", typeOnTime),
      d3.csv("./csv/ontime7.csv", typeOnTime),
      d3.csv("./csv/ontime8.csv", typeOnTime),
      d3.csv("./csv/ontime9.csv", typeOnTime),
    ]).then(function(allData) {
      onTimeData = typeOnTime(allData)
      xScaleOnTime = d3.scaleBand()
        .domain(["Ontime", "Overdue"])
        .range([0, w])
        .padding([0.5])

      for(var i = 0; i < onTimeData.length; i++)
      {
        let y = d3.scaleLinear()
          .domain([onTimeData[i][0].count + onTimeData[i][1].count, 0])
          .range([0, h - margin.bottom])
        yScalesOnTime.push(y)
      }
      renderOnTime(onTimeData, 0);
    });
			
    function switchDistrict(district)
    {

      updateOnTime(onTimeData, district);
      update(ccd_data_total, district, allXScalesTotal, 0 )
      update(ccd_data_overdue, district, allXScalesOverdue, 1)
    }

    // renders (initally) the "ontime vs overdue bar chart"
    function renderOnTime(data, district)
    {
      //selects container and appends SVG and a group inside the SVG
      svg = d3.select("#container")
        .append("div")
        .attr("id", "ontime")
          .append("svg")
            .attr("width", w + margin.left + margin.right)
            .attr("height", h + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");
    
      // creates and stores axis
      yAxis_ontime = svg.append("g")
        .call(d3.axisLeft(yScalesOnTime[district]));
      // append the svg object to the #container of the page

      
      // Show the bars
      svg
        .selectAll("rect")
        .data(data[district])
        .enter().append("rect") 
          .attr("fill", function(d) { return color((d.time == "Ontime") ? 0 : 1) })
          .attr("x", function(d) {  return xScaleOnTime(d.time); })
          .attr("y", function(d) { return h - margin.bottom - yScalesOnTime[district](d.count)})
          .attr("height", function(d) { return yScalesOnTime[district](d.count); })
          .attr("width",xScaleOnTime.bandwidth()) 

      //creates y axis
      svg.append("g")
        .attr("transform", "translate(0," + (h - margin.bottom)  + ")")
        .call(d3.axisBottom(xScaleOnTime).tickSizeOuter(0))
        .selectAll("text")  
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-40)" );
    }

    // renders stacked bar chart
    function render(data, district, xScales, index) {
      console.log(data);
      // selects container and adds a div with ID and and SVG
      svg = d3.select("#container")
        .append("div")
        .attr("id", "top10_" + index)
          .append("svg")
            .attr("width", w + margin.left + margin.right)
            .attr("height", h + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");
      // Show the bars
      svg.append("g")
          .classed("bar", true)
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(data[district])
          .enter().append("g")
            .attr("fill", function(d) { return color(clamp(d[0][0], 0, 1)); })
            .selectAll("rect")
            // enter a second time = loop subgroup per subgroup to add all rectangles
            .data(function(d) { return d; })
            .enter().append("rect")
              .attr("x", function(d) { if(xScales[district](d.data.type) == undefined) console.log(d.data.type); return xScales[district](d.data.type); })
              .attr("y", function(d) {  return y[index](d[1]); })
              .attr("height", function(d) { return y[index](d[0]) - y[index](d[1]); })
              .attr("width",xScales[district].bandwidth())

      svg.append("g")
        .call(d3.axisLeft(y[index]));

      

      
      svg.append("g")
        .classed("xaxis", true)
        .attr("transform", "translate(0," + (h - margin.bottom)  + ")")
        .call(d3.axisBottom(xScales[district]).tickSizeOuter(0))
        .selectAll("text")  
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-40)" );
      
            
    }

    function update(data, district, xScales, index) {
      var bargroups = d3.select("#top10_" + index).select("svg").select("g").select(".bar").selectAll("g")
        .data(data[district]);
      var rects = bargroups.selectAll("rect")
        .data(function(d) { return d; });
      var xaxis = d3.select("#top10_" + index).select("svg").select("g").select(".xaxis");
      
      bargroups
        .enter()
        .append("g")
        .merge(bargroups)
        .transition()
        .duration(1000)
        .attr("fill", function(d) { return color(clamp(d[0][0], 0, 1)); })
      
      rects
          .enter().append("rect")
            .merge(rects)
            .transition()
            .duration(1000)
            .attr("x", function(d) { if(xScales[district](d.data.type) == undefined) console.log(d.data.type); return xScales[district](d.data.type); })
            .attr("y", function(d) {  return y[index](d[1]); })
            .attr("height", function(d) { return y[index](d[0]) - y[index](d[1]); })
            .attr("width",xScales[district].bandwidth())

      xaxis
        .transition()
        .duration(1000)
        .call(d3.axisBottom(xScales[district]).tickSizeOuter(0))
        .selectAll("text")  
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-40)" );
      

    }

    // updates the ontime vs overdue bar chart
    function updateOnTime(data, district)
    {

      // transition axis to axis for district
      yAxis_ontime.transition().duration(1000).call(d3.axisLeft(yScalesOnTime[district]));

      // select bars
      var bars = d3.select("#ontime").select("svg").select("g").selectAll("rect")
        .data(data[district]);
      console.log(bars);
      // enter the new data
      bars
        .enter()
        .append("rect")
        .merge(bars)
        .transition()
        .duration(1000)
          .attr("x", function(d) {  return xScaleOnTime(d.time); })
          .attr("y", function(d) { return h - margin.bottom - yScalesOnTime[district](d.count)})
          .attr("height", function(d) { return yScalesOnTime[district](d.count); })
          .attr("width",xScaleOnTime.bandwidth())

    }
    
    // this is necessary to turn these numeric attributes to js number types, and on time into a boolean
    function type(d) {
        d.type = d.type;
        d.ontime = +d.ontime
        d.overdue = +d.overdue
        
        return d;
    } 

    function typeOnTime(d) {
        d.time = (d.ontime != "ONTIME") ? "Ontime" : "Overdue";
        d.count = +d.count;
        return d;
    } 

		</script>
	</body>
</html>