<html>
<head>
  <title>A D3 map</title>
  <script type="text/javascript" src="./d3.js"></script>
  <script src="neighborhoods.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <style>
    #neighborhoods path{
      fill: #ccc;
    }
.container {
  float: left;
}
  </style>
<div>
  <svg id="switch_data"> </svg></div>
</div>
</head>
<div class ="container"><svg id="map"> </svg></div>

<div class ="container">
  <svg id="my_dataviz2"></svg>
</div>
<body>
  <script>


// https://stackoverflow.com/questions/45421774/how-to-draw-circles-with-radii-given-in-kilometers-accurately-on-world-map
var circumference = 6371000 * Math.PI * 2;
var angle = 1000 / circumference * 360;

var circle = d3.geoCircle().center([-71.1256, 42.2724]).radius(angle);





var width = 400,
    height = 400;

var svg = d3.select( "#map" )
  .attr( "width", width )
  .attr( "height", height );

var neighborhoods = svg.append( "g" ).attr( "id", "neighborhoods" );

var svg = d3.select("#my_dataviz2").attr( "width", width ).attr( "height", height );
var legend = svg.append('g').attr("id","legend")

var albersProjection = d3.geoAlbers()
  .scale( 100000 )
  .rotate( [71.057,0] )
  .center( [0, 42.313] )
  .translate( [width/2,height/2] );

var geoPath = d3.geoPath()
    .projection( albersProjection );

neighborhoods.selectAll( "path" )
  .data( neighborhoods_json.features )
  .enter()
  .append( "path" )
  .attr( "d", geoPath )
  .style("stroke", "#fff")
  ;

  neighborhoods.append("path")
  .attr("d", geoPath(circle()))
  .style("fill","Red")
  .attr("opacity","0.5");


  neighborhoods.selectAll( "text" )
  .data( neighborhoods_json.features )
  .enter()
  .append( "text" )
  .attr("x", function(d) {
                   return albersProjection( albersProjection.invert (geoPath.centroid(d))) [0];
           })
           .attr("y", function(d) {
                   return albersProjection( albersProjection.invert (geoPath.centroid(d))) [1];
           })
  .attr("fill", "black")
  .style("text-anchor", "middle")
  .style("font-size","10px")
  .text(function(d){ return d.properties.Name})
  .raise();

  var zoom_transform ={trans:null};


  function type(d) {
          d.latitude = +d.latitude;
          d.longitude = +d.longitude;
          return d;
      } 
data = d3.csv("./clean.csv", type).then(render)
_render_switch_data()
const remove = new Set()

function _render_switch_data(){

  var data = ["clean","quiet"]
  var width =100,height = 50;

  var svg = d3.select( "#switch_data" )
    .attr( "width", "100%" )
    .attr( "height", height );
    g = svg.append("g")
     
   
        // Add one dot in the legend for each name.
        g.selectAll("dots")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", function(d,i){ return 10+i*100})
        .attr("cy", 25 ) // 100 is where the first dot appears. 25 is the distance between dots
        .attr("r", 7)
        .attr("id",function(d,i){ return  !i ? "clean": "quiet"})
        .style("fill", function(d,i){ return  !i ? "red": "white"})
        .style("stroke", function(d,i){ return   "red"})
        .on('click',on_click_filter)

      // Add one dot in the legend for each name.
      g.selectAll("labels")
        .data(data)
        .enter()
        .append("text")
        .attr("x", function(d,i){ return 30+i*100})
        .attr("y", 25 )  // 100 is where the first dot appears. 25 is the distance between dots
          .style("fill", function(d){ return "black"})
          .text(function(d){ return d})
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle")


    function on_click_filter(event,d){
      var new_data;
        if (d3.select(this).style("fill") == "white"){
          d3.select(this).style("fill","red")
          .attr("stroke",function(d){ return "white"})
          var isclean = d3.select(this).attr('id') == "clean"
          if (isclean){
            d3.select("#quiet").style("fill","white")
            d3.csv("./clean.csv").then(render)
          }
          else{
            d3.select("#clean").style("fill","white")
            d3.csv("./quiet.csv").then(render)
          }
        }
    }

}


function _render_map(new_data,color,zoom_transform){
  console.log(zoom_transform)
var circles = neighborhoods.selectAll("circle").attr('transform',zoom_transform.trans).data(new_data,function(d) { return(d); });
circles.enter()
  .append( "circle" )
  .attr( "cx", function(d){
    return albersProjection( [d.longitude,d.latitude] )[0] ;
  })
  .attr( "cy", function(d){
    return albersProjection( [d.longitude,d.latitude] )[1] ;
  })
  .attr("r", 2)
  .attr("fill",d=>color(d.type)).style("opacity", 0.8)

  .on( "click", function(){
    d3.select(this)
      .attr("opacity",1)
      .transition()
      .duration( 1000 )
      .attr( "cx", width * Math.round( Math.random() ) )
      .attr( "cy", height * Math.round( Math.random() ) )
      
      .attr( "opacity", 0 )
      .on("end",function(){
        d3.select(this).remove();
      })
  });
  circles.exit().remove()
  neighborhoods.selectAll('text').raise();
  if(zoom_transform.trans){
  neighborhoods.selectAll("circle")
                  .attr('transform', zoom_transform.trans);
  neighborhoods.selectAll("circle")
                  .attr('r',2/zoom_transform.trans.k)
  }
}

function _render_label(data, keys,color,zoom_transform){

  function on_click_filter(event,d){
    var new_data;
      if (d3.select(this).style("fill") != "white"){
        d3.select(this).style("fill","white")
        .attr("stroke",function(d){ return color(d)})
        remove.add(d)
        new_data = data.filter(function(d){return !remove.has(d.type)})
        
      }
      else {
        d3.select(this).style("fill",function(d){ return color(d)}).attr("stroke","white")
        remove.delete(d)
        new_data = data.filter(function(d){return !remove.has(d.type)})
      }
      _render_map(new_data,color,zoom_transform)

}

  
 
    // Add one dot in the legend for each name.
    colors =legend.selectAll("circle")
      .data(keys,function(d){return d});
    colors.enter()
      .append("circle")
        .attr("cx", 100)
        .attr("cy", function(d,i){ return 100 + i*25}) // 100 is where the first dot appears. 25 is the distance between dots
        .attr("r", 7)
        .style("fill", function(d){ return color(d)})
        .on('click',on_click_filter);
    colors.exit().remove();

      // Add one dot in the legend for each name.
      labels = legend.selectAll("text")
        .data(keys,function(d){return d});
      labels.enter()
        .append("text")
          .attr("x", 120)
          .attr("y", function(d,i){ return 100 + i*25}) // 100 is where the first dot appears. 25 is the distance between dots
          .style("fill", function(d){ return color(d)})
          .text(function(d){ return d})
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle");

          labels.exit().remove();
            
}
     
function render(data) {
   
    var keys = new Set(data.map(x=>x.type))

    var color = d3.scaleOrdinal().domain(keys).range(d3.schemeSet1);

    _render_map(data,color,zoom_transform)
    _render_label(data,keys,color,zoom_transform)
    


        var zoom = d3.zoom()
              .scaleExtent([1, 10])
              .on('zoom', function(event,d) {
                zoom_transform.trans=event.transform
                
                neighborhoods.selectAll('path')
                  .attr('transform', event.transform);
                  neighborhoods.selectAll("circle")
                  .attr('transform', event.transform);
                  neighborhoods.selectAll("circle")
                  .attr('r',2/event.transform.k)
                neighborhoods.selectAll('text')
                .attr('transform', event.transform).style("font-size",10/event.transform.k+"px").raise();
        });

        neighborhoods.call(zoom);
}


function distance(lat1, lon1, lat2, lon2, unit) {
	if ((lat1 == lat2) && (lon1 == lon2)) {
		return 0;
	}
	else {
		var radlat1 = Math.PI * lat1/180;
		var radlat2 = Math.PI * lat2/180;
		var theta = lon1-lon2;
		var radtheta = Math.PI * theta/180;
		var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
		if (dist > 1) {
			dist = 1;
		}
		dist = Math.acos(dist);
		dist = dist * 180/Math.PI;
		dist = dist * 60 * 1.1515;
		if (unit=="K") { dist = dist * 1.609344 }
		if (unit=="N") { dist = dist * 0.8684 }
		return dist;
	}
}
  </script>
</body>
</html>